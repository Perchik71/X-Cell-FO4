// Copyright © 2023 aka perchik71. All rights reserved.
// Contacts: <email:timencevaleksej@gmail.com>
// License: https://www.gnu.org/licenses/lgpl-3.0.html

#pragma once

#include "vbase.h"
#include <stddef.h>
#include <stdint.h>

namespace voltek
{
	namespace core
	{
		// Класс для битовых манипуляций.
		// Битовая карта, всё взаимодействие в битах.
		//
		// Например:
		// bits _bit_map(100000);
		// _bit_map.set(9090);
		// _bit_map.dump("test.data");
		//
		// В данном примере создаётся карта мз 100.000 битов,
		// где 9090 бит устанавливается как 1, а после чего
		// сохраняем дамп памяти в файл.
		class bits : public base
		{
		public:
			// Конструктор по умолчанию.
			bits();
			// Конструктор.
			// В качестве параметра указывается кол-во желаемых битов.
			bits(size_t count);
			// Конструктор копий.
			bits(const bits& ob);
			// Деструктор.
			virtual ~bits();
			// Оператор присвоения
			bits& operator=(const bits& ob);
			// Установить все биты равно 1.
			void all_set();
			// Установить все биты равно 0.
			void all_unset();
			// Изменяет кол-во допустимых битов.
			// В качестве параметра указывается кол-во желаемых битов.
			// Если указать 0, то будет освобождена память
			// При уменьшении объёма вызовет перерасчёт установленных битов, это очень медленно.
			void resize(size_t count);
			// Функция возвращает если объект класса пуст и нет памяти.
			inline bool empty() const { return !_count; }
			// Освобождение памяти.
			inline void clear() { resize(0); }
			// Возвращает кол-во допустимых битов.
			inline size_t count() const { return _count; }
			// Возвращает указатель на память, константа.
			inline const char* c_data() const { return _mem; }
			// Возвращает указатель на память, не константа.
			inline char* data() { return _mem; }
			// Возвращает размер выделенной памяти под этот объект класса.
			size_t size() const;
			// Возвращает истину, если бит за заданным индексом "bit_index" бит равен 0.
			inline bool is_unset(size_t bit_index) const { return !is_set(bit_index); }
			// Возвращает истину, если бит за заданным индексом "bit_index" бит равен 1.
			inline bool is_set(size_t bit_index) const { return (_mem[index_from_bit_index(bit_index)] & (char)1 << (bit_index - ((bit_index >> 3) << 3))) != 0; }
			// Устанавливает бит за заданным индексом "bit_index" в 0, если он был равен 1.
			// Возвращает истину, если операция прошла успешно.
			// Успех будет только в том случаи, если функция "is_set" вернёт истину, что
			// значит бит был равен 1.
			bool unset(size_t bit_index);
			// Устанавливает бит за заданным индексом "bit_index" в 1, если он был равен 0.
			// Возвращает истину, если операция прошла успешно.
			// Успех будет только в том случаи, если функция "is_unset" вернёт истину, что
			// значит бит был равен 0.
			bool set(size_t bit_index);
			// Перерасчёт установленных битов.
			// Очень неоптимизированный способ восстановления кол-ва установленных бит.
			// Не рекомендуется.
			void update_sets();
			// Возвращает кол-во установленных битов на 1.
			inline size_t get_sets_count() const { return _sets; }
			// Возвращает кол-во установленных битов на 0.
			inline size_t get_unsets_count() const { return _count - _sets; }
			// Установлены все биты на 1.
			inline bool is_all_sets() const { return _sets == _count; }
			// Установлены все биты на 0.
			inline bool is_all_unsets() const { return !_sets; }
			// Вывод дампа битовой карты.
			void dump(const char* file_name) const;
			// Поиск первого установленного бита в памяти.
			// Возвращает истину, тогда "index" содержит индекс бита, который установлен как 1.
			// Если ложь, то значит все биты установлены как 0.
			bool find_first_set_bit(size_t& index) const;
		protected:
			// Возвращает индекс в массиве данных из индекса бита.
			// Все данные выделяются в байтах, а смещение в массиве в зависимости от типа данных, но не меньше байта.
			// 
			// Например: В байте 8 бит, поэтому нам нужно индекс бита логически сдвинуть в право на 3, короче говоря поделить на 8.
			inline size_t index_from_bit_index(size_t bit_index) const { return bit_index >> 3; }
		private:
			// Поиск первого установленного бита AVX2 инструкциями
			bool find_first_set_bit_avx2(size_t& index) const;
			// Поиск первого установленного бита SSE4.1 инструкциями
			bool find_first_set_bit_sse41(size_t& index) const;
			// Поиск первого установленного бита для самых древних ЦПУ
			bool find_first_set_bit_none(size_t& index, size_t start = 0) const;
		private:
			// Память
			char* _mem;
			// Кол-во допустимых битов
			size_t _count;
			// Кол-во установленных битов
			size_t _sets;
		};

		// Класс для битовых манипуляций.
		// Битовая карта, всё взаимодействие в битах.
		// (Разделена на регионы в кол-ве 16 штук, для более быстрого поиска первого
		// установленного бита как 1). Только, для больших карт.
		//
		// Например:
		// bits _bit_map(100000);
		// _bit_map.set(9090);
		// _bit_map.dump("test.data");
		//
		// В данном примере создаётся карта мз 100.000 битов,
		// где 9090 бит устанавливается как 1, а после чего
		// сохраняем дамп памяти в файл.
		class bits_regions : public base
		{
		public:
			// Конструктор по умолчанию.
			bits_regions();
			// Конструктор.
			// В качестве параметра указывается кол-во желаемых битов.
			bits_regions(size_t count);
			// Конструктор копий.
			bits_regions(const bits_regions& ob);
			// Оператор присвоения
			bits_regions& operator=(const bits_regions& ob);
			// Деструктор.
			virtual ~bits_regions();
			// Установить все биты равно 1.
			void all_set();
			// Установить все биты равно 0.
			void all_unset();
			// Изменяет кол-во допустимых битов.
			// В качестве параметра указывается кол-во желаемых битов.
			// Если указать 0, то будет освобождена память
			// При уменьшении объёма вызовет перерасчёт установленных битов, это очень медленно.
			// Меньше 65536 нельзя.
			// Внимание: Прежде чем изменить размер, нужно сделать clear().
			// Перераспределение регионов и установленных в ней битов не реализовано.
			void resize(size_t count);
			// Функция возвращает если объект класса пуст и нет памяти.
			inline bool empty() const { return !_count; }
			// Освобождение памяти.
			inline void clear() { resize(0); }
			// Возвращает кол-во допустимых битов.
			inline size_t count() const { return _count; }
			// Возвращает размер выделенной памяти под этот объект класса.
			size_t size() const;
			// Возвращает истину, если бит за заданным индексом "bit_index" бит равен 0.
			inline bool is_unset(size_t bit_index) const { return !is_set(bit_index); }
			// Возвращает истину, если бит за заданным индексом "bit_index" бит равен 1.
			bool is_set(size_t bit_index) const;
			// Возвращает кол-во установленных битов на 1.
			inline size_t get_sets_count() const { return _sets; }
			// Возвращает кол-во установленных битов на 0.
			inline size_t get_unsets_count() const { return _count - _sets; }
			// Установлены все биты на 1.
			inline bool is_all_sets() const { return _sets == _count; }
			// Установлены все биты на 0.
			inline bool is_all_unsets() const { return !_sets; }
			// Устанавливает бит за заданным индексом "bit_index" в 0, если он был равен 1.
			// Возвращает истину, если операция прошла успешно.
			// Успех будет только в том случаи, если функция "is_set" вернёт истину, что
			// значит бит был равен 1.
			bool unset(size_t bit_index);
			// Устанавливает бит за заданным индексом "bit_index" в 1, если он был равен 0.
			// Возвращает истину, если операция прошла успешно.
			// Успех будет только в том случаи, если функция "is_unset" вернёт истину, что
			// значит бит был равен 0.
			bool set(size_t bit_index);
			// Вывод дампа битовой карты.
			void dump(const char* file_name) const;
			// Поиск первого установленного бита в памяти.
			// Возвращает истину, тогда "index" содержит индекс бита, который установлен как 1.
			// Если ложь, то значит все биты установлены как 0.
			bool find_first_set_bit(size_t& index) const;
		private:
			// Информация о начальных и конечных битов в регионе.
			struct region
			{
				size_t start;
				size_t end;
			} _regions[16];
			// Кол-во доступных битов.
			size_t _count;
			// Кол-во установленных битов как 1.
			size_t _sets;
			// Дистанция между регионами в битах.
			size_t _distance;
			// Маска регионов
			// Данное число используется для определения региона,
			// где был установлен бит как 1.
			// При всех установленных битов как 0 в регионе, в маске
			// помечается как 0.
			uint16_t _region_map;
			// 16 битовых карт, типо регионы.
			bits _region_bits[16];
		};
	}
}